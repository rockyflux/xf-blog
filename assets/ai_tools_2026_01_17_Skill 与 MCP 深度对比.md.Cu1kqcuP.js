import{_ as a,c as n,o as t,a4 as p}from"./chunks/framework.TNqKmmQz.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ai/tools/2026/01/17/Skill 与 MCP 深度对比.md","filePath":"ai/tools/2026/01/17/Skill 与 MCP 深度对比.md","lastUpdated":1768906306000}'),e={name:"ai/tools/2026/01/17/Skill 与 MCP 深度对比.md"};function l(i,s,o,r,d,c){return t(),n("div",null,s[0]||(s[0]=[p(`<h2 id="skill-与-mcp-深度对比" tabindex="-1">Skill 与 MCP 深度对比 <a class="header-anchor" href="#skill-与-mcp-深度对比" aria-label="Permalink to &quot;Skill 与 MCP 深度对比&quot;">​</a></h2><p>首先，官方文档非常值得细细品味，看完官方文档倒也可以考虑不用看其他的文章了（针对 skill，mcp 这一块感觉描述一般，mcp 太多东西了）：</p><p><a href="https://code.claude.com/docs/zh-CN/skills" target="_blank" rel="noreferrer"># Agent Skills</a></p><p><a href="https://platform.claude.com/docs/zh-CN/agents-and-tools/agent-skills/overview" target="_blank" rel="noreferrer"># Agent Skills 概览</a></p><p># 通过 MCP 将 Claude Code 连接到工具</p><hr><h2 id="一、token-占用对比-这个大家应该都知道-不过多描述" tabindex="-1">一、Token 占用对比，这个大家应该都知道，不过多描述 <a class="header-anchor" href="#一、token-占用对比-这个大家应该都知道-不过多描述" aria-label="Permalink to &quot;一、Token 占用对比，这个大家应该都知道，不过多描述&quot;">​</a></h2><h3 id="_1-1-mcp-全量加载模式" tabindex="-1">1.1 MCP：全量加载模式 <a class="header-anchor" href="#_1-1-mcp-全量加载模式" aria-label="Permalink to &quot;1.1 MCP：全量加载模式&quot;">​</a></h3><p>MCP 在会话启动时<strong>全量加载</strong>所有工具定义到上下文：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>会话启动 → 加载所有 MCP 服务器 → 注入全部工具定义（JSON-Schema）</span></span></code></pre></div><p><strong>就拿我使用的 mcp 来说</strong>：</p><table tabindex="0"><thead><tr><th><strong>MCP 服务器</strong></th><th><strong>工具数</strong></th><th><strong>Token 占用</strong></th></tr></thead><tbody><tr><td>auggie-mcp</td><td>1</td><td>~1k</td></tr><tr><td>grok-search</td><td>5</td><td>~3k</td></tr><tr><td>memory</td><td>9</td><td>~5k</td></tr><tr><td>sequential-thinking</td><td>1</td><td>~2k</td></tr><tr><td><strong>多服务器叠加</strong></td><td>-</td><td><strong>轻松突破 10k+</strong></td></tr></tbody></table><p>随便用几个占用就非常大了</p><h3 id="_1-2-skill-按需加载模式" tabindex="-1">1.2 Skill：按需加载模式 <a class="header-anchor" href="#_1-2-skill-按需加载模式" aria-label="Permalink to &quot;1.2 Skill：按需加载模式&quot;">​</a></h3><p>Skill 采用<strong>渐进式披露</strong>，仅在需要时加载：</p><table tabindex="0"><thead><tr><th><strong>阶段</strong></th><th><strong>加载内容</strong></th><th><strong>Token 占用</strong></th></tr></thead><tbody><tr><td>启动时</td><td>仅 <code>name</code> + <code>description</code> 索引</td><td>~10-100 tokens/skill</td></tr><tr><td>触发时</td><td>完整 <code>SKILL.md</code> 内容</td><td>~1,000-5,000 tokens/skill</td></tr></tbody></table><p><strong>我使用的 skill</strong>：90K 的 Skills 目录，<code>/context</code> 仅显示 <strong>513 tokens</strong>，和 mcp 对比起来，非常直观。</p><h3 id="_1-3-简单对比" tabindex="-1">1.3 简单对比 <a class="header-anchor" href="#_1-3-简单对比" aria-label="Permalink to &quot;1.3 简单对比&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>维度</strong></th><th><strong>MCP</strong></th><th><strong>Skill</strong></th></tr></thead><tbody><tr><td>启动时占用</td><td>全量（10k+ tokens）</td><td>索引（~500 tokens）</td></tr><tr><td>使用时增量</td><td>无（已加载）</td><td>按需逐步加载</td></tr></tbody></table><hr><h2 id="二、设计模式对比" tabindex="-1">二、设计模式对比 <a class="header-anchor" href="#二、设计模式对比" aria-label="Permalink to &quot;二、设计模式对比&quot;">​</a></h2><h3 id="_2-1-mcp-全量注入-json-schema" tabindex="-1">2.1 MCP：全量注入 + JSON-Schema <a class="header-anchor" href="#_2-1-mcp-全量注入-json-schema" aria-label="Permalink to &quot;2.1 MCP：全量注入 + JSON-Schema&quot;">​</a></h3><h4 id="什么是-mcp" tabindex="-1">什么是 MCP？ <a class="header-anchor" href="#什么是-mcp" aria-label="Permalink to &quot;什么是 MCP？&quot;">​</a></h4><p>MCP（Model Context Protocol）即模型上下文协议，采用 <strong>Host-Client-Server</strong> 三层架构：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Host</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Claude Code)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    │</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ├── Client ←──</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RPC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">──→ context7 Server              </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ├── Client ←──</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RPC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">──→ sequential</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">thinking Server   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    └── Client ←──</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RPC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">──→ your Server</span></span></code></pre></div><table tabindex="0"><thead><tr><th><strong>角色</strong></th><th><strong>是什么</strong></th></tr></thead><tbody><tr><td><strong>Host</strong></td><td>AI 应用程序（比如 Claude Code、VS Code、Cursor 等）</td></tr><tr><td><strong>Client</strong></td><td>通信管道，负责与 Server 建立连接、发送 JSON-RPC 请求、接收响应</td></tr><tr><td><strong>Server</strong></td><td>提供工具 / 上下文的程序（== 日常说的「安装 MCP」就是安装 Server==）</td></tr><tr><td><strong>JSON-RPC</strong></td><td>Client 与 Server 之间传输的数据格式（所有 MCP 都遵守此协议）</td></tr><tr><td><strong>Tool Schema</strong></td><td>启动时 Server 返回的「工具说明书」，告诉 Claude 有哪些工具、怎么调用</td></tr></tbody></table><blockquote><p>Host 和 Client 由应用自动管理，<strong>开发者 / 使用者只需关注 Server</strong>。再比如 FastMCP 框架会自动处理协议细节。</p></blockquote><h4 id="mcp-server-目录结构-这里以-python-为例" tabindex="-1">MCP Server 目录结构（这里以 Python 为例） <a class="header-anchor" href="#mcp-server-目录结构-这里以-python-为例" aria-label="Permalink to &quot;MCP Server 目录结构（这里以 Python 为例）&quot;">​</a></h4><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>my-mcp-server/</span></span>
<span class="line"><span>├── pyproject.toml            # 包定义（必需）</span></span>
<span class="line"><span>│   ├── name = &quot;mcp-server-xxx&quot;</span></span>
<span class="line"><span>│   └── version = &quot;1.0.0&quot;</span></span>
<span class="line"><span>├── src/</span></span>
<span class="line"><span>│   ├── server.py             # 入口，初始化 FastMCP</span></span>
<span class="line"><span>│   ├── tools.py              # Tool 定义（单文件，适合 &lt;10 个工具）</span></span>
<span class="line"><span>│   ├── tools/                # Tool 定义（多文件，按功能拆分）</span></span>
<span class="line"><span>│   │   ├── __init__.py</span></span>
<span class="line"><span>│   │   ├── search.py</span></span>
<span class="line"><span>│   │   └── fetch.py</span></span>
<span class="line"><span>│   └── resources.py          # Resource 提供者（可选）</span></span>
<span class="line"><span>└── README.md</span></span></code></pre></div><blockquote><p><code>tools.py</code> 和 <code>tools/</code> 二选一，可根据数量决定。</p></blockquote><h4 id="tool-定义示例" tabindex="-1">Tool 定义示例 <a class="header-anchor" href="#tool-定义示例" aria-label="Permalink to &quot;Tool 定义示例&quot;">​</a></h4><p>从这里就可以看出，其实和接口非常像，请求 -&gt; 回调数据，实际上多数的 mcp 也都可以理解成三方接口。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mcp.server.fastmcp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FastMCP</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mcp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FastMCP(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;weather&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@mcp.tool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_weather</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;Get weather for a location.&quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Weather in </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">{</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">location</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">: 72°F, Sunny&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> __name__</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;__main__&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mcp.run(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">transport</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;stdio&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h4 id="客户端配置结构-mcpservers" tabindex="-1">客户端配置结构（mcpServers） <a class="header-anchor" href="#客户端配置结构-mcpservers" aria-label="Permalink to &quot;客户端配置结构（mcpServers）&quot;">​</a></h4><p><strong>配置示例</strong>：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>  &quot;args&quot;: [</span></span>
<span class="line"><span>    &quot;-y&quot;,</span></span>
<span class="line"><span>    &quot;@upstash/context7-mcp&quot;</span></span>
<span class="line"><span>  ],</span></span>
<span class="line"><span>  &quot;command&quot;: &quot;npx&quot;,</span></span>
<span class="line"><span>  &quot;type&quot;: &quot;stdio&quot;</span></span>
<span class="line"><span>}</span></span></code></pre></div><blockquote><p>mcp 服务器的 json 格式，让配置起来非常方便，cv 万岁</p></blockquote><h3 id="_2-2-skill-渐进式披露-markdown" tabindex="-1">2.2 Skill：渐进式披露 + Markdown <a class="header-anchor" href="#_2-2-skill-渐进式披露-markdown" aria-label="Permalink to &quot;2.2 Skill：渐进式披露 + Markdown&quot;">​</a></h3><h4 id="什么是-skill" tabindex="-1">什么是 Skill？ <a class="header-anchor" href="#什么是-skill" aria-label="Permalink to &quot;什么是 Skill？&quot;">​</a></h4><p>Skill 是 Claude Code 的<strong>知识 / 流程包</strong>，本质是一个 Markdown 文件夹，用于：</p><p>注入领域知识（如代码规范、业务逻辑）</p><p>定义工作流程（如代码审查 SOP、部署流程）</p><p>封装可复用的脚本和模板 ==（这直接导致 Skill 与 MCP 在使用体验上趋于相似）==</p><p><strong>额外说明：</strong></p><p>Skill 只能提供指导，无法执行外部 API 调用、网络请求、会话管理等操作，毕竟只是 md 文件夹，但是能指导 cc 运行脚本，包括但不限于自带的脚本资源，这句话应该会有嚼头。</p><h4 id="skill-目录结构-双层架构" tabindex="-1">Skill 目录结构（双层架构） <a class="header-anchor" href="#skill-目录结构-双层架构" aria-label="Permalink to &quot;Skill 目录结构（双层架构）&quot;">​</a></h4><blockquote><p>以下规范取自 <code>skill-creator</code> Skill, 我觉得配置比 cc 官方文档里面的描述更详细</p></blockquote><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>skill-name/</span></span>
<span class="line"><span>├── SKILL.md (必需)</span></span>
<span class="line"><span>│   ├── YAML frontmatter ──→ 索引层（始终加载，~100 words）</span></span>
<span class="line"><span>│   │   ├── name: (必需)</span></span>
<span class="line"><span>│   │   └── description: (必需，唯一触发机制)</span></span>
<span class="line"><span>│   └── Markdown 正文 ────→ 内容层（触发时加载，建议 &lt;500 行）</span></span>
<span class="line"><span>└── Bundled Resources (可选) ──→ 内容层（按需加载）</span></span>
<span class="line"><span>    ├── scripts/      - 可执行脚本（Python/Bash）</span></span>
<span class="line"><span>    ├── references/   - 参考文档（Claude 判断需要时加载）</span></span>
<span class="line"><span>    └── assets/       - 输出资源（模板、图片，不加载到上下文）</span></span></code></pre></div><p><strong>双层架构说明</strong>：</p><p><strong>索引层</strong>：YAML frontmatter 中的 name/description，始终在上下文中</p><p><strong>内容层</strong>：SKILL.md 正文 + 捆绑资源，仅在触发时选择性加载</p><h4 id="核心设计原则" tabindex="-1">核心设计原则 <a class="header-anchor" href="#核心设计原则" aria-label="Permalink to &quot;核心设计原则&quot;">​</a></h4><p><strong>description 是唯一触发机制</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># ✅ 好的 description（包含触发场景）</span></span>
<span class="line"><span>description: &gt;</span></span>
<span class="line"><span>  Comprehensive document creation and editing with tracked changes.</span></span>
<span class="line"><span>  Use when Claude needs to work with .docx files for:</span></span>
<span class="line"><span>  (1) Creating new documents, (2) Modifying content,</span></span>
<span class="line"><span>  (3) Working with tracked changes, (4) Adding comments</span></span>
<span class="line"><span></span></span>
<span class="line"><span># ❌ 差的 description（太模糊）</span></span>
<span class="line"><span>description: A useful document tool</span></span></code></pre></div><h4 id="渐进式披露模式" tabindex="-1">渐进式披露模式 <a class="header-anchor" href="#渐进式披露模式" aria-label="Permalink to &quot;渐进式披露模式&quot;">​</a></h4><blockquote><p>是不是觉得模式 1,3 非常相似？我也觉得。不过 <code>skill-creator</code> 还是分成了这三种，就全罗列出来了</p></blockquote><p><strong>模式 1：高层指南 + 引用</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># PDF Processing</span></span>
<span class="line"><span></span></span>
<span class="line"><span>## Quick start</span></span>
<span class="line"><span>[核心代码示例]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>## Advanced features</span></span>
<span class="line"><span>- **Form filling**: See [FORMS.md](references/FORMS.md)</span></span>
<span class="line"><span>- **API reference**: See [REFERENCE.md](references/REFERENCE.md)</span></span></code></pre></div><p>Claude 仅在需要时加载 FORMS.md 或 REFERENCE.md。</p><p><strong>模式 2：按领域 / 变体组织</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cloud-deploy/</span></span>
<span class="line"><span>├── SKILL.md (工作流 + 选择指南)</span></span>
<span class="line"><span>└── references/</span></span>
<span class="line"><span>    ├── aws.md    ← 用户选 AWS 时才加载</span></span>
<span class="line"><span>    ├── gcp.md</span></span>
<span class="line"><span>    └── azure.md</span></span></code></pre></div><p><strong>模式 3：条件详情</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>## Editing documents</span></span>
<span class="line"><span>For simple edits, modify XML directly.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>**For tracked changes**: See [REDLINING.md](references/REDLINING.md)</span></span>
<span class="line"><span>**For OOXML details**: See [OOXML.md](references/OOXML.md)</span></span></code></pre></div><h4 id="工作流程" tabindex="-1">工作流程 <a class="header-anchor" href="#工作流程" aria-label="Permalink to &quot;工作流程&quot;">​</a></h4><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>用户请求 → Claude 扫描所有 Skill 的 description → 匹配 → 加载 SKILL.md 正文 → 按需加载 references → 执行</span></span></code></pre></div><p><strong>特点</strong>：</p><p><strong>宽松定义</strong>：Markdown 格式，自然语言描述</p><p><strong>懒加载</strong>：渐进式加载</p><p><strong>可编排</strong>：Markdown 可表达流程顺序和条件分支</p><p><strong>本质</strong>：流程 / 知识包（SOP 手册）</p><hr><h2 id="三、版本管理与更新便利性" tabindex="-1">三、版本管理与更新便利性 <a class="header-anchor" href="#三、版本管理与更新便利性" aria-label="Permalink to &quot;三、版本管理与更新便利性&quot;">​</a></h2><p><strong>结论先行</strong>：MCP 在版本管理上<strong>绝对优于</strong> Skill。</p><h3 id="_3-1-mcp-成熟的包管理生态" tabindex="-1">3.1 MCP：成熟的包管理生态 <a class="header-anchor" href="#_3-1-mcp-成熟的包管理生态" aria-label="Permalink to &quot;3.1 MCP：成熟的包管理生态&quot;">​</a></h3><h4 id="核心机制" tabindex="-1">核心机制 <a class="header-anchor" href="#核心机制" aria-label="Permalink to &quot;核心机制&quot;">​</a></h4><p>MCP 直接复用 npm/PyPI 成熟生态，版本管理由包管理器自动处理。</p><p><strong>工作原理</strong>：</p><p>MCP 服务器以 npm 包（js/ts）或 PyPI 包（Python）形式发布</p><p>使用 <code>npx</code> 或 <code>uvx</code> 命令启动时，包管理器会自动处理下载和缓存</p><p>版本号定义在 <code>package.json</code>（npm）或 <code>pyproject.toml</code>（PyPI）中</p><p><strong>更新行为</strong>：</p><table tabindex="0"><thead><tr><th><strong>模式</strong></th><th><strong>行为</strong></th><th><strong>启动速度</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>默认</strong></td><td>使用本地缓存，不查询 registry</td><td>快</td><td>日常使用</td></tr><tr><td><strong>强制更新</strong></td><td>每次查询 registry，版本变化时才下载（<code>@latest</code> 或 <code>--refresh</code>）</td><td>慢</td><td>需要最新版本时</td></tr></tbody></table><p><strong>获取方式对比</strong>：</p><table tabindex="0"><thead><tr><th><strong>获取方式</strong></th><th><strong>配置示例</strong></th><th><strong>更新机制</strong></th></tr></thead><tbody><tr><td><strong>npx (npm)</strong></td><td><code>npx -y @pkg/server</code></td><td>默认用缓存，需 <code>@latest</code> 或清缓存强制更新</td></tr><tr><td><strong>uvx (pip)</strong></td><td><code>uvx mcp-server-fetch</code></td><td>默认用缓存，需 <code>--refresh</code> 或清缓存强制更新</td></tr><tr><td><strong>本地命令</strong></td><td><code>auggie --mcp</code></td><td>需手动 <code>pip install --upgrade</code></td></tr></tbody></table><p><strong>配置示例</strong>：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// ~/.claude.json</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  &quot;mcpServers&quot;: {</span></span>
<span class="line"><span>    &quot;memory&quot;: {</span></span>
<span class="line"><span>      &quot;command&quot;: &quot;npx&quot;,</span></span>
<span class="line"><span>      &quot;args&quot;: [&quot;-y&quot;, &quot;@modelcontextprotocol/server-memory&quot;]</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="如何更新" tabindex="-1">如何更新 <a class="header-anchor" href="#如何更新" aria-label="Permalink to &quot;如何更新&quot;">​</a></h4><p><strong>推荐方式：手动清理缓存</strong></p><p>当 MCP 服务器有新版本时，清理缓存即可：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 清理 npx 缓存</span></span>
<span class="line"><span>rm -rf ~/.npm/_npx #（不推荐！不推荐！不推荐！）</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 清理 uvx 缓存</span></span>
<span class="line"><span>uv cache clean #（不推荐！不推荐！不推荐！）</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 上述的清理会清理系统中所有的缓存，但mcp的缓存位置各有不同，需要主动寻找，且无规律可言，最好还是让cc自己来吧</span></span></code></pre></div><p><strong>工作流程</strong>：</p><p>清理缓存</p><p>重启 Claude Code</p><p>自动下载最新版本</p><p><strong>优点</strong>：日常启动快，需要更新时才清理缓存</p><p><strong>不推荐使用</strong> <strong>@latest</strong> <strong>或 --refresh</strong></p><p>虽然可以自动更新，但会显著影响启动速度（每次都查询 registry）。</p><p>配置示例：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>  &quot;mcpServers&quot;: {</span></span>
<span class="line"><span>    &quot;memory&quot;: {</span></span>
<span class="line"><span>      &quot;command&quot;: &quot;npx&quot;,</span></span>
<span class="line"><span>      &quot;args&quot;: [&quot;-y&quot;, &quot;@modelcontextprotocol/server-memory@latest&quot;]</span><span>  // npx 使用 @latest</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>    &quot;fetch&quot;: {</span></span>
<span class="line"><span>      &quot;command&quot;: &quot;uvx&quot;,</span></span>
<span class="line"><span>      &quot;args&quot;: [&quot;--refresh&quot;, &quot;mcp-server-fetch&quot;]</span><span>  // uvx 使用 --refresh</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre></div><hr><h3 id="_3-2-skill-普遍缺乏版本管理" tabindex="-1">3.2 Skill：普遍缺乏版本管理 <a class="header-anchor" href="#_3-2-skill-普遍缺乏版本管理" aria-label="Permalink to &quot;3.2 Skill：普遍缺乏版本管理&quot;">​</a></h3><h4 id="现状-一般来说-skill-没有版本管理" tabindex="-1">现状：一般来说 Skill 没有版本管理 <a class="header-anchor" href="#现状-一般来说-skill-没有版本管理" aria-label="Permalink to &quot;现状：一般来说 Skill 没有版本管理&quot;">​</a></h4><p>与 MCP 不同，<strong>一般来说 Skill 没有任何版本管理机制</strong>：</p><p>没有版本号定义</p><p>没有版本锁定</p><p>手动管理</p><p>Skill 在某些时候更像可以随意定制的小玩具，在原本的基础上又能随意修改</p><p><strong>Skill 的获取与更新方式</strong>：</p><table tabindex="0"><thead><tr><th><strong>获取方式</strong></th><th><strong>更新方式</strong></th><th><strong>版本控制</strong></th></tr></thead><tbody><tr><td>GitHub 克隆</td><td><code>git pull</code> 手动更新</td><td>依赖 Git commit hash</td></tr><tr><td>下载 ZIP 文件</td><td>手动替换文件</td><td><strong>无</strong></td></tr><tr><td>CC 直接生成</td><td>即时生效</td><td><strong>无</strong></td></tr></tbody></table><p><strong>问题</strong>：</p><p>用户不知道 Skill 是否有新版本</p><p>无法回滚到特定版本（除非使用 Git）</p><hr><h4 id="例外-官方-marketplace-需登录" tabindex="-1">例外：官方 Marketplace（需登录） <a class="header-anchor" href="#例外-官方-marketplace-需登录" aria-label="Permalink to &quot;例外：官方 Marketplace（需登录）&quot;">​</a></h4><p><strong>唯一的版本管理方案</strong>是官方 Marketplace，但有严格限制：</p><p><strong>必须登录</strong>：API Key 用户无法使用</p><p><strong>非标准化</strong>：没有强制的版本号格式</p><p><strong>Marketplace 版本管理示例</strong>：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// marketplace.json</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  &quot;name&quot;: &quot;my-plugins&quot;,</span></span>
<span class="line"><span>  &quot;plugins&quot;: [</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>      &quot;name&quot;: &quot;review-plugin&quot;,</span></span>
<span class="line"><span>      &quot;source&quot;: &quot;./plugins/review-plugin&quot;,</span></span>
<span class="line"><span>      &quot;version&quot;: &quot;2.1.0&quot;</span><span>  // ← 需要手动维护</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  ]</span></span>
<span class="line"><span>}</span></span></code></pre></div><p><strong>限制</strong>：</p><p>仅适用于官方 Marketplace 中的 Skill</p><p>无法用于自定义或第三方 Skill</p><p>API Key 用户完全无法使用</p><p>ps：这一块应该是这样的吧，没有官号诶</p><hr><h4 id="skill-的独特优势" tabindex="-1">Skill 的独特优势 <a class="header-anchor" href="#skill-的独特优势" aria-label="Permalink to &quot;Skill 的独特优势&quot;">​</a></h4><p>尽管缺乏版本管理，Skill 还有一个 MCP 无法比拟的优势：</p><p><strong>即时生效</strong>：修改 Skill 文件后无需重启服务，下次触发时自动加载最新内容。</p><p><strong>对比 MCP</strong>：</p><p><strong>MCP</strong>：修改后需重启 Claude Code 才能生效</p><p><strong>Skill</strong>：适合快速迭代和调试，改完即用</p><p><strong>适用场景</strong>：</p><p>个人定制化 Skill（频繁调整）</p><p>快速原型验证</p><hr><h2 id="四、我推荐-使用-slash-command-稳定触发" tabindex="-1">四、我推荐：使用 Slash Command 稳定触发 <a class="header-anchor" href="#四、我推荐-使用-slash-command-稳定触发" aria-label="Permalink to &quot;四、我推荐：使用 Slash Command 稳定触发&quot;">​</a></h2><p><strong>事先声明：</strong> 这里的 /ccg 不是使用的 skill，我才发现，哎呀！！</p><p>但是我都按照这个写了，不想再改了。</p><p><code>/ccg</code> 的工作流程是 /cmd → 自己的脚本<br> 请你们假装 是 /cmd → skill → skill 的脚本</p><h3 id="_4-1-skill-的触发不确定性问题" tabindex="-1">4.1 Skill 的触发不确定性问题 <a class="header-anchor" href="#_4-1-skill-的触发不确定性问题" aria-label="Permalink to &quot;4.1 Skill 的触发不确定性问题&quot;">​</a></h3><p>Skill 依赖 Claude <strong>自动匹配描述</strong>，存在以下问题：</p><p>该触发时未触发（描述不够精准）</p><p>不该触发时误触发（描述过于宽泛）</p><p><strong>实际体验</strong>：虽然 Skill 理论上能够自动触发，但实际触发率较低。比如我即使在 CLAUDE.md 中明确写了 &quot;让 Codex 和 Gemini 参与协作&quot;，Claude 偶尔还是会忽略。所以之前我都会主动在需求后面添加这句话。</p><p><strong>解决方案</strong>：使用 cmd 可以 <strong>100% 稳定触发</strong>。例如：<code>/ccg:feat 需求描述</code> 总比主动描述或者期待 cc 记得安心。</p><h3 id="_4-2-最佳实践-skill-command-工作流组合" tabindex="-1">4.2 最佳实践：Skill + Command 工作流组合 <a class="header-anchor" href="#_4-2-最佳实践-skill-command-工作流组合" aria-label="Permalink to &quot;4.2 最佳实践：Skill + Command 工作流组合&quot;">​</a></h3><p><strong>为什么需要 Command</strong>：</p><p>Skill 可能包含复杂的命令调用和参数配置，这些细节难以通过自然语言稳定触发。例如：</p><p>外部工具调用：<code>/home/nobug/.claude/bin/codeagent-wrapper --backend gemini</code></p><p>带参数的指令：<code>--backend codex</code>、<code>--SESSION_ID xxx</code></p><p>多阶段工作流：需要按特定顺序执行多个步骤</p><p>这些精确的指令和参数通过语言描述很难稳定触发，而 Command 可以将这些细节明确定义在文件中。</p><p><strong>模式 1 示例</strong>（简单流程）：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>场景：应用主题到 Artifact</span></span>
<span class="line"><span></span></span>
<span class="line"><span>├── ~/.claude/skills/theme-factory/</span></span>
<span class="line"><span>│   └── SKILL.md                    # 主题定义、应用指南</span></span>
<span class="line"><span>└── ~/.claude/commands/</span></span>
<span class="line"><span>    └── theme-factory.md            # 内容：&quot;Execute the theme-factory skill&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>用户输入 /theme-factory 应用深色主题</span></span>
<span class="line"><span>    ↓</span></span>
<span class="line"><span>Command 触发 → Claude 加载 SKILL.md → 自主执行</span></span></code></pre></div><p><strong>模式 2 示例</strong>（复杂流程）：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>场景：前端专项开发</span></span>
<span class="line"><span></span></span>
<span class="line"><span>└── ~/.claude/commands/ccg/</span></span>
<span class="line"><span>    └── frontend.md                 # 完整工作流定义</span></span>
<span class="line"><span></span></span>
<span class="line"><span>用户输入 /ccg:frontend 实现响应式导航栏</span></span>
<span class="line"><span>    ↓</span></span>
<span class="line"><span>Claude 加载 frontend.md 内容</span></span>
<span class="line"><span>    ↓</span></span>
<span class="line"><span>按照 Command 中定义的 6 个阶段执行：</span></span>
<span class="line"><span>  1. Prompt 增强（可选）</span></span>
<span class="line"><span>  2. 研究（代码检索）</span></span>
<span class="line"><span>  3. 构思（调用 Gemini 分析）</span></span>
<span class="line"><span>  4. 计划（调用 Gemini 规划）</span></span>
<span class="line"><span>  5. 执行（Claude 实施）</span></span>
<span class="line"><span>  6. 优化（调用 Gemini 审查）</span></span></code></pre></div><p><strong>外部工具说明</strong>：像 <code>codeagent-wrapper</code> 这样的工具是<strong>外部可执行文件</strong>（位于 <code>~/.claude/bin/</code>），不是 Skill。Skill 只能提供指导，无法执行外部 API 调用、网络请求、会话管理等操作，这些必须由外部工具完成。</p><p><strong>核心原则</strong>：</p><p><strong>稳定性优先</strong>：复杂流程用 Command 定义，确保稳定执行</p><p><strong>外部工具必须用 Command</strong>：Skill 无法执行外部命令</p><p><strong>简单场景用 Skill</strong>：减少维护成本，提高灵活性</p>`,161)]))}const k=a(e,[["render",l]]);export{g as __pageData,k as default};
