import{_ as p}from"./chunks/ArticleMetadata.QIgyFqOu.js";import{_ as g,C as i,c as A,o as s,j as l,G as S,a4 as u,a as d,w as k,b as h,e as b}from"./chunks/framework.TNqKmmQz.js";import"./chunks/theme.5WaCU3Xi.js";const N=JSON.parse('{"title":"SubAgent 与 Skills：AI Agent 的两种扩展方式","description":"","frontmatter":{"title":"SubAgent 与 Skills：AI Agent 的两种扩展方式","author":"箫风","date":"2026/01/17 15:00","isTop":false,"categories":["AI相关"],"tags":["Skills","SubAgent"]},"headers":[],"relativePath":"ai/models/2026/01/17/SubAgent与Skills：AI Agent的两种扩展方式.md","filePath":"ai/models/2026/01/17/SubAgent与Skills：AI Agent的两种扩展方式.md","lastUpdated":1768913029000}'),c={name:"ai/models/2026/01/17/SubAgent与Skills：AI Agent的两种扩展方式.md"};function _(e,t,m,f,I,q){const r=p,o=i("ClientOnly");return s(),A("div",null,[t[0]||(t[0]=l("h1",{id:"subagent-与-skills-ai-agent-的两种扩展方式",tabindex:"-1"},[d("SubAgent 与 Skills：AI Agent 的两种扩展方式 "),l("a",{class:"header-anchor",href:"#subagent-与-skills-ai-agent-的两种扩展方式","aria-label":'Permalink to "SubAgent 与 Skills：AI Agent 的两种扩展方式"'},"​")],-1)),S(o,null,{default:k(()=>{var n,a;return[(((n=e.$frontmatter)==null?void 0:n.aside)??!0)&&(((a=e.$frontmatter)==null?void 0:a.showArticleMetadata)??!0)?(s(),h(r,{key:0,article:e.$frontmatter},null,8,["article"])):b("",!0)]}),_:1}),t[1]||(t[1]=u('<p>一句话解释 SubAgent 和 Skills 的区别：<strong>AI Agent 就像操作系统，Skills 就像应用程序，SubAgent 也是操作系统，不过预装了应用，并且像虚拟机一样运行，独立上下文。</strong></p><hr><h2 id="skills-教-agent-新技能" tabindex="-1"><strong>Skills：教 Agent 新技能</strong> <a class="header-anchor" href="#skills-教-agent-新技能" aria-label="Permalink to &quot;**Skills：教 Agent 新技能**&quot;">​</a></h2><p><strong>Skills 是一份“操作手册”。</strong></p><p>你招了个聪明的助理，但他对你的业务一无所知。每次布置任务，你都得从头解释流程、注意事项、工具用法。Skills 就是把这些知识写成文档，Agent 需要时自己去翻阅，不用你反复交代。</p><p>比如我写了一个“给文章配图”的 Skill，它告诉 Agent：</p><p>• 怎么分析文章找出需要配图的位置</p><p>• 有哪些风格可选（科技感、温暖、极简……）</p><p>• 怎么写图像生成的提示词</p><p>• 图片存哪里、怎么命名</p><p>Agent 启动时只记住“有这么个配图技能”，大概 100 个 token，真正要用时才去读详细内容。这叫**“渐进式加载”**，好处是装一堆 Skill 也不会撑爆上下文。</p><p><img src="https://s2.loli.net/2026/01/20/a9Cy1JG8rjP275v.jpg" alt="Skills 按需加载示意图"></p><hr><h2 id="subagent-开个虚拟机干活" tabindex="-1"><strong>SubAgent：开个虚拟机干活</strong> <a class="header-anchor" href="#subagent-开个虚拟机干活" aria-label="Permalink to &quot;**SubAgent：开个虚拟机干活**&quot;">​</a></h2><p><strong>SubAgent 是独立运行的“专家助手”。</strong></p><p>它有自己的上下文窗口，相当于自己的“工作记忆”。干完活只把结果交回来，中间过程不会污染主 Agent 的思维空间。</p><p>你是项目经理，手下有三个专家。你不需要盯着他们每一步操作，只需要告诉他们任务目标，等他们交报告就行。</p><p><img src="https://s2.loli.net/2026/01/20/JSxao2e3kq5GYHg.jpg" alt="SubAgent 独立上下文示意图"></p><hr><h2 id="一个真实案例-给文章配图" tabindex="-1"><strong>一个真实案例：给文章配图</strong> <a class="header-anchor" href="#一个真实案例-给文章配图" aria-label="Permalink to &quot;**一个真实案例：给文章配图**&quot;">​</a></h2><p>假设我写完一篇文章，想配三套不同风格的插图方案，让用户自己选。</p><p><strong>如果只用 Skills：</strong></p><p>主 Agent 分析文章 → 设计三种方案 → 调用画图 Skill 画第一套 → 画完再画第二套 → 再画第三套</p><p>问题来了：</p><p>1. <strong>上下文爆炸</strong>：三套图的生成过程全堆在主 Agent 的“脑子”里，几十张图的提示词、中间结果、错误重试……全占着位置</p><p>2. <strong>速度慢</strong>：必须一个接一个画，串行执行</p><p><strong>如果用 SubAgent + Skills：</strong></p><p>主 Agent 分析文章 → 设计三种方案 → 同时启动三个 SubAgent</p><p>每个 SubAgent：</p><p>• 预装了“画图 Skill”</p><p>• 拿到文章路径和自己负责的方案</p><p>• 独立去读文章、生成提示词、调用画图工具、插入图片</p><p>• 完成后只返回：新文章的 URL + 简短摘要</p><p>主 Agent 这边呢？<strong>上下文干干净净</strong>，只有三个结果链接。用户想看哪套，再去读取对应的 URL。</p><p><img src="https://s2.loli.net/2026/01/20/uIN856yOEmgAMDq.jpg" alt="纯 Skills vs SubAgent+Skills 流程对比"></p><hr><h2 id="什么时候用哪个" tabindex="-1"><strong>什么时候用哪个？</strong> <a class="header-anchor" href="#什么时候用哪个" aria-label="Permalink to &quot;**什么时候用哪个？**&quot;">​</a></h2><p><strong>用 Skills：</strong></p><p>• 任务简单，主 Agent 全程掌控</p><p>• 需要的知识可以复用</p><p>• 想节省上下文，按需加载</p><p><strong>用 SubAgent：</strong></p><p>• 子任务复杂、耗时长、中间过程繁琐</p><p>• 需要并行处理多个独立任务</p><p>• 想保持主 Agent 的“思维清晰”</p><hr><h2 id="一句话总结" tabindex="-1"><strong>一句话总结</strong> <a class="header-anchor" href="#一句话总结" aria-label="Permalink to &quot;**一句话总结**&quot;">​</a></h2><p>Skills 是应用程序，装在主系统里按需调用；SubAgent 是虚拟机，独立运行完再把结果交回来。<strong>任务简单用应用，任务复杂开虚拟机。</strong></p>',48))])}const T=g(c,[["render",_]]);export{N as __pageData,T as default};
