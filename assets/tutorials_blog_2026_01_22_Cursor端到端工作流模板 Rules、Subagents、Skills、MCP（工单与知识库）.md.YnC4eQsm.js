import{_ as p}from"./chunks/ArticleMetadata.DRjrHxp2.js";import{_ as o,C as c,c as u,o as n,j as i,G as d,a4 as h,a as g,w as b,b as _,e as y}from"./chunks/framework.TNqKmmQz.js";import"./chunks/theme.5WaCU3Xi.js";const A=JSON.parse('{"title":"Cursor 端到端工作流模板：Rules、Subagents、Skills、MCP（工单与知识库）","description":"","frontmatter":{"title":"Cursor 端到端工作流模板：Rules、Subagents、Skills、MCP（工单与知识库）","author":"箫风","date":"2026/01/22 18:05","isTop":false,"categories":["开发教程"],"tags":["Cursor","AI编程","Agent","Subagents","Skills","MCP","工单","知识库"]},"headers":[],"relativePath":"tutorials/blog/2026/01/22/Cursor端到端工作流模板 Rules、Subagents、Skills、MCP（工单与知识库）.md","filePath":"tutorials/blog/2026/01/22/Cursor端到端工作流模板 Rules、Subagents、Skills、MCP（工单与知识库）.md","lastUpdated":1769657413000}'),m={name:"tutorials/blog/2026/01/22/Cursor端到端工作流模板 Rules、Subagents、Skills、MCP（工单与知识库）.md"};function k(s,a,f,C,P,q){const t=p,r=c("ClientOnly");return n(),u("div",null,[a[0]||(a[0]=i("h1",{id:"cursor-端到端工作流模板-rules、subagents、skills、mcp-工单与知识库",tabindex:"-1"},[g("Cursor 端到端工作流模板：Rules、Subagents、Skills、MCP（工单与知识库） "),i("a",{class:"header-anchor",href:"#cursor-端到端工作流模板-rules、subagents、skills、mcp-工单与知识库","aria-label":'Permalink to "Cursor 端到端工作流模板：Rules、Subagents、Skills、MCP（工单与知识库）"'},"​")],-1)),d(r,null,{default:b(()=>{var l,e;return[(((l=s.$frontmatter)==null?void 0:l.aside)??!0)&&(((e=s.$frontmatter)==null?void 0:e.showArticleMetadata)??!0)?(n(),_(t,{key:0,article:s.$frontmatter},null,8,["article"])):y("",!0)]}),_:1}),a[1]||(a[1]=h(`<p>这篇不讲概念对照，直接给你一套<strong>可复制到项目里</strong>的工作流模板（并对齐官方能力边界，避免“看起来能做但实际上不一定配置好了”）：</p><ul><li>用 <strong>Rules</strong> 固化团队协作约束</li><li>用 <strong>Subagents</strong> 把“实现/测试/验收/安全审计”拆开并行/串行</li><li>用 <strong>Skills</strong> 把部署、校验、文档生成做成可执行能力包（注：Skills 目前需 nightly）</li><li>用 <strong>MCP（工单/知识库类）</strong> 接入 Jira/Confluence（或同类系统），把“交付闭环”同步到系统记录</li></ul><p>你可以把它当成一个“Cursor 驱动的交付流水线”。</p><h2 id="_1-目标-一次需求交付的标准流水线" tabindex="-1">1. 目标：一次需求交付的标准流水线 <a class="header-anchor" href="#_1-目标-一次需求交付的标准流水线" aria-label="Permalink to &quot;1. 目标：一次需求交付的标准流水线&quot;">​</a></h2><p>我建议把一次交付拆为 6 步：</p><ol><li><strong>计划</strong>：输出可执行方案（主 agent）</li><li><strong>实现</strong>：按计划改代码（主 agent）</li><li><strong>测试</strong>：主动跑测试并修复（<code>test-runner</code> subagent）</li><li><strong>安全审计</strong>：找风险点与硬编码密钥（<code>security-auditor</code> subagent，建议 <code>readonly: true</code>）</li><li><strong>文档</strong>：更新 README / 变更说明 / 复盘模板（<code>docs-writer</code> skill）</li><li><strong>同步外部系统</strong>：更新工单状态、写入知识库（MCP）</li></ol><h2 id="_2-你需要放进仓库的文件树-可直接照抄" tabindex="-1">2. 你需要放进仓库的文件树（可直接照抄） <a class="header-anchor" href="#_2-你需要放进仓库的文件树-可直接照抄" aria-label="Permalink to &quot;2. 你需要放进仓库的文件树（可直接照抄）&quot;">​</a></h2><blockquote><p>说明：下面是“目标结构”，你可以按实际项目做增删。</p></blockquote><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docs/tutorials/blog/（这是你博客文章目录，与项目无关）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.cursor/</span></span>
<span class="line"><span>  rules/</span></span>
<span class="line"><span>    00-project-basics.md</span></span>
<span class="line"><span>    10-testing-policy.md</span></span>
<span class="line"><span>    20-security-baseline.md</span></span>
<span class="line"><span>  agents/</span></span>
<span class="line"><span>    verifier.md</span></span>
<span class="line"><span>    test-runner.md</span></span>
<span class="line"><span>    security-auditor.md</span></span>
<span class="line"><span>  skills/   (nightly 才可用)</span></span>
<span class="line"><span>    docs-writer/</span></span>
<span class="line"><span>      SKILL.md</span></span>
<span class="line"><span>      references/</span></span>
<span class="line"><span>        DOCS_STYLE.md</span></span>
<span class="line"><span>    deploy-app/</span></span>
<span class="line"><span>      SKILL.md</span></span>
<span class="line"><span>      scripts/</span></span>
<span class="line"><span>        deploy.sh</span></span>
<span class="line"><span>        validate.py</span></span>
<span class="line"><span>      assets/</span></span>
<span class="line"><span>        config-template.json</span></span></code></pre></div><p>如果你不想引入 <code>.cursor/rules/</code> 的结构化规则，也可以用 <code>AGENTS.md</code>（放仓库根目录 + 子目录；官方支持嵌套并自动合并，更具体的指令优先）。</p><h2 id="_3-rules-最小可用规则集-建议" tabindex="-1">3. Rules：最小可用规则集（建议） <a class="header-anchor" href="#_3-rules-最小可用规则集-建议" aria-label="Permalink to &quot;3. Rules：最小可用规则集（建议）&quot;">​</a></h2><p>Rules 的目标不是“写一部规范圣经”，而是让 Agent 在关键决策点不跑偏。</p><p>对齐官方术语，你可以把规则按三种方式组织：</p><ul><li><strong>Always Apply</strong>：每次对话都注入（<code>alwaysApply: true</code>），只放少量硬约束</li><li><strong>Apply Intelligently</strong>：由 Agent 根据 <code>description</code> 判断是否注入（更推荐）</li><li><strong>Apply to Specific Files</strong>：用 <code>globs</code> 只对特定文件范围生效（例如只对 <code>frontend/**</code> 生效）</li></ul><p>当规则需要引用项目里的长文档或模板时，建议把内容拆成独立文件，并在规则/对话中用 <code>@filename</code> 的方式按需包含进上下文。</p><h3 id="_3-1-00-project-basics-建议-非-alwaysapply" tabindex="-1">3.1 <code>00-project-basics</code>（建议：非 alwaysApply） <a class="header-anchor" href="#_3-1-00-project-basics-建议-非-alwaysapply" aria-label="Permalink to &quot;3.1 \`00-project-basics\`（建议：非 alwaysApply）&quot;">​</a></h3><p>内容包含：</p><ul><li>代码结构边界（业务逻辑/接口层/持久化层分离）</li><li>变更策略（小步提交、避免大爆炸式重构）</li><li>输出约束（变更说明必须包含影响范围与回滚方案）</li></ul><h3 id="_3-2-10-testing-policy-建议-可以-alwaysapply" tabindex="-1">3.2 <code>10-testing-policy</code>（建议：可以 alwaysApply） <a class="header-anchor" href="#_3-2-10-testing-policy-建议-可以-alwaysapply" aria-label="Permalink to &quot;3.2 \`10-testing-policy\`（建议：可以 alwaysApply）&quot;">​</a></h3><p>内容包含：</p><ul><li>何时必须补测试</li><li>测试命名/目录约定</li><li>失败处理：先定位根因，再最小修复</li></ul><h3 id="_3-3-20-security-baseline-建议-非-alwaysapply" tabindex="-1">3.3 <code>20-security-baseline</code>（建议：非 alwaysApply） <a class="header-anchor" href="#_3-3-20-security-baseline-建议-非-alwaysapply" aria-label="Permalink to &quot;3.3 \`20-security-baseline\`（建议：非 alwaysApply）&quot;">​</a></h3><p>内容包含：</p><ul><li>禁止硬编码密钥</li><li>输入校验与输出编码</li><li>日志脱敏约定</li></ul><h2 id="_4-subagents-三类就够用-先别贪多" tabindex="-1">4. Subagents：三类就够用（先别贪多） <a class="header-anchor" href="#_4-subagents-三类就够用-先别贪多" aria-label="Permalink to &quot;4. Subagents：三类就够用（先别贪多）&quot;">​</a></h2><h3 id="_4-1-verifier-专门做-验收与反证" tabindex="-1">4.1 verifier：专门做“验收与反证” <a class="header-anchor" href="#_4-1-verifier-专门做-验收与反证" aria-label="Permalink to &quot;4.1 verifier：专门做“验收与反证”&quot;">​</a></h3><p>用途：解决常见问题——AI 说“完成了”，但功能其实没通。</p><p>关键点：</p><ul><li>让它保持怀疑态度</li><li>明确要求它： <ul><li>找到声称完成的点</li><li>给出验证步骤</li><li>必要时要求运行测试/最小手工验证</li></ul></li></ul><h3 id="_4-2-test-runner-主动跑测试并修复失败-use-proactively" tabindex="-1">4.2 test-runner：主动跑测试并修复失败（use proactively） <a class="header-anchor" href="#_4-2-test-runner-主动跑测试并修复失败-use-proactively" aria-label="Permalink to &quot;4.2 test-runner：主动跑测试并修复失败（use proactively）&quot;">​</a></h3><p>用途：在出现代码变更后自动拉起测试，并迭代修复。</p><p>关键点：</p><ul><li><code>description</code> 里写“Use proactively”</li><li>强制它“保持测试意图不变”</li></ul><h3 id="_4-3-security-auditor-安全审计-建议-readonly" tabindex="-1">4.3 security-auditor：安全审计（建议 readonly） <a class="header-anchor" href="#_4-3-security-auditor-安全审计-建议-readonly" aria-label="Permalink to &quot;4.3 security-auditor：安全审计（建议 readonly）&quot;">​</a></h3><p>用途：在 auth/payments/敏感数据处理、或任何引入外部依赖时做一次审计。</p><p>关键点：</p><ul><li>建议 <code>readonly: true</code></li><li>输出要按严重程度分级：Critical/High/Medium</li></ul><h2 id="_5-skills-把-重复流程-做成可复用能力包" tabindex="-1">5. Skills：把“重复流程”做成可复用能力包 <a class="header-anchor" href="#_5-skills-把-重复流程-做成可复用能力包" aria-label="Permalink to &quot;5. Skills：把“重复流程”做成可复用能力包&quot;">​</a></h2><blockquote><p>提醒：Agent Skills 需要 nightly 渠道。</p></blockquote><p>我建议先做两类 skill：</p><ul><li><code>docs-writer</code>：把文档更新标准化</li><li><code>deploy-app</code>：把部署/校验脚本化</li></ul><h3 id="_5-1-docs-writer-的写法建议" tabindex="-1">5.1 docs-writer 的写法建议 <a class="header-anchor" href="#_5-1-docs-writer-的写法建议" aria-label="Permalink to &quot;5.1 docs-writer 的写法建议&quot;">​</a></h3><ul><li><code>SKILL.md</code> 只写“什么时候用 + 输出结构”</li><li>长的文档规范放 <code>references/</code>，让 Agent 需要时再加载</li></ul><h3 id="_5-2-deploy-app-的写法建议" tabindex="-1">5.2 deploy-app 的写法建议 <a class="header-anchor" href="#_5-2-deploy-app-的写法建议" aria-label="Permalink to &quot;5.2 deploy-app 的写法建议&quot;">​</a></h3><ul><li><code>scripts/validate.py</code>：部署前校验（配置、环境、依赖）</li><li><code>scripts/deploy.sh</code>：真正部署动作</li><li>脚本要： <ul><li>输出明确错误信息</li><li>可重复执行（幂等）</li><li>能在失败时给出下一步建议</li></ul></li></ul><h2 id="_6-mcp-工单-知识库类-让交付闭环到-系统记录" tabindex="-1">6. MCP（工单/知识库类）：让交付闭环到“系统记录” <a class="header-anchor" href="#_6-mcp-工单-知识库类-让交付闭环到-系统记录" aria-label="Permalink to &quot;6. MCP（工单/知识库类）：让交付闭环到“系统记录”&quot;">​</a></h2><p>本模板里，MCP 的目标不是“替代工程师”，而是把交付闭环自动化：</p><ul><li><strong>工单系统</strong>：把任务状态、关键结论、风险点沉淀到 Jira/Linear/ClickUp</li><li><strong>知识库</strong>：把复盘、发布说明、操作手册同步到 Confluence/Notion 类系统</li></ul><h3 id="_6-1-典型接入方式与注意事项" tabindex="-1">6.1 典型接入方式与注意事项 <a class="header-anchor" href="#_6-1-典型接入方式与注意事项" aria-label="Permalink to &quot;6.1 典型接入方式与注意事项&quot;">​</a></h3><p>你会遇到两类 MCP server：</p><ul><li>本地 <code>stdio</code>（CLI 启动）</li><li>远程 <code>sse/http/https</code>（托管服务）</li></ul><p>工程建议：</p><ul><li>团队协作系统优先 <strong>OAuth</strong></li><li>默认只读；需要写入时再显式开写入工具（最小权限）</li><li>不要把 token 写进仓库，统一通过环境变量或密钥管理注入</li></ul><p>另外，子代理会继承父代理的工具（包括已配置的 MCP 工具）。但内置的某些子代理（例如文档里提到的 <code>computerUse</code>）会显式排除 Task 工具；自定义子代理通常会继承父代理的工具集。</p><h3 id="_6-2-你在工作流里怎么用-建议固定-3-个动作" tabindex="-1">6.2 你在工作流里怎么用（建议固定 3 个动作） <a class="header-anchor" href="#_6-2-你在工作流里怎么用-建议固定-3-个动作" aria-label="Permalink to &quot;6.2 你在工作流里怎么用（建议固定 3 个动作）&quot;">​</a></h3><p>把 MCP 的使用约束为固定动作，最不容易失控：</p><ol><li><strong>开始任务</strong>：把工单切到 In Progress，并写入“计划链接/分支名”</li><li><strong>完成实现</strong>：写入“变更摘要 + 风险点 + 回滚方案”</li><li><strong>交付完成</strong>：把工单切到 Done，并在知识库创建/更新复盘页（包含测试结果与关键决策）</li></ol><p>在落地时，建议把“可写入的 MCP 操作”限制在这三个动作里（而不是让 Agent 任意写 Confluence/Jira），这样更符合团队审计与最小权限原则。</p><h2 id="_7-一次完整执行脚本-你可以直接照抄到对话里" tabindex="-1">7. 一次完整执行脚本（你可以直接照抄到对话里） <a class="header-anchor" href="#_7-一次完整执行脚本-你可以直接照抄到对话里" aria-label="Permalink to &quot;7. 一次完整执行脚本（你可以直接照抄到对话里）&quot;">​</a></h2><p>下面是一段“对话模板”，目的是让主 agent 主动调度 subagent/skill/mcp（你只需要替换工单链接和项目实际的测试命令即可）：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>目标：完成工单 XXX（链接）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>约束：</span></span>
<span class="line"><span>- 遵循项目 Rules</span></span>
<span class="line"><span>- 变更必须有测试与回滚说明</span></span>
<span class="line"><span></span></span>
<span class="line"><span>步骤：</span></span>
<span class="line"><span>1) 你先给出计划（含文件清单与验证步骤）</span></span>
<span class="line"><span>2) 实现完成后，启动 /test-runner 跑相关测试并修复失败</span></span>
<span class="line"><span>3) 再启动 /security-auditor 做一次安全审计（只读）</span></span>
<span class="line"><span>4) 再启动 /verifier 验收端到端功能是否真的可用</span></span>
<span class="line"><span>5) 用 docs-writer skill 生成变更说明与知识库更新草稿</span></span>
<span class="line"><span>6) 通过 MCP：</span></span>
<span class="line"><span>   - 更新工单状态与结论</span></span>
<span class="line"><span>   - 更新知识库页面</span></span></code></pre></div><h2 id="_8-常见坑与修正" tabindex="-1">8. 常见坑与修正 <a class="header-anchor" href="#_8-常见坑与修正" aria-label="Permalink to &quot;8. 常见坑与修正&quot;">​</a></h2><ul><li>Subagents 太多：先从 verifier/test-runner/security-auditor 三个开始</li><li>description 太空：导致永远不会自动委派</li><li>把所有规则设为 alwaysApply：上下文变噪音，反而变慢</li><li>MCP 默认给写权限：容易误写；团队环境必须最小权限</li></ul><p>补充一点务实提醒：Subagent 并行时 token 消耗会随并行数上升，简单任务不一定要拆子代理。</p><h2 id="_9-下一步建议-团队化" tabindex="-1">9. 下一步建议（团队化） <a class="header-anchor" href="#_9-下一步建议-团队化" aria-label="Permalink to &quot;9. 下一步建议（团队化）&quot;">​</a></h2><ul><li>把 <code>.cursor/agents/</code> 提交仓库，全员复用</li><li>把 Rules 拆成“少量强约束 + 多量智能应用”</li><li>MCP 统一由团队维护与审计（尤其是写入能力）</li></ul>`,66))])}const w=o(m,[["render",k]]);export{A as __pageData,w as default};
