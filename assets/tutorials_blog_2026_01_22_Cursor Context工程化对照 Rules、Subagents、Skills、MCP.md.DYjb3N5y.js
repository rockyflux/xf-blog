import{_ as n}from"./chunks/ArticleMetadata.DRjrHxp2.js";import{_ as d,C as c,c as u,o as a,j as s,G as h,a4 as g,a as p,w as m,b,e as k}from"./chunks/framework.TNqKmmQz.js";import"./chunks/theme.5WaCU3Xi.js";const y=JSON.parse('{"title":"Cursor Context 工程化对照：Rules、Subagents、Skills、MCP","description":"","frontmatter":{"title":"Cursor Context 工程化对照：Rules、Subagents、Skills、MCP","author":"箫风","date":"2026/01/22 18:05","isTop":false,"categories":["开发教程"],"tags":["Cursor","AI编程","Agent","Subagents","Skills","MCP"]},"headers":[],"relativePath":"tutorials/blog/2026/01/22/Cursor Context工程化对照 Rules、Subagents、Skills、MCP.md","filePath":"tutorials/blog/2026/01/22/Cursor Context工程化对照 Rules、Subagents、Skills、MCP.md","lastUpdated":1769657413000}'),_={name:"tutorials/blog/2026/01/22/Cursor Context工程化对照 Rules、Subagents、Skills、MCP.md"};function C(l,e,P,S,f,q){const r=n,i=c("ClientOnly");return a(),u("div",null,[e[0]||(e[0]=s("h1",{id:"cursor-context-工程化对照-rules、subagents、skills、mcp",tabindex:"-1"},[p("Cursor Context 工程化对照：Rules、Subagents、Skills、MCP "),s("a",{class:"header-anchor",href:"#cursor-context-工程化对照-rules、subagents、skills、mcp","aria-label":'Permalink to "Cursor Context 工程化对照：Rules、Subagents、Skills、MCP"'},"​")],-1)),h(i,null,{default:m(()=>{var t,o;return[(((t=l.$frontmatter)==null?void 0:t.aside)??!0)&&(((o=l.$frontmatter)==null?void 0:o.showArticleMetadata)??!0)?(a(),b(r,{key:0,article:l.$frontmatter},null,8,["article"])):k("",!0)]}),_:1}),e[1]||(e[1]=g('<p>把 Cursor 用好，关键不是“把提示词写长”，而是把协作系统工程化：哪些东西应该<strong>持久化</strong>、哪些东西需要<strong>上下文隔离</strong>、哪些东西适合<strong>打包复用</strong>、哪些东西要通过<strong>外部工具/系统</strong>闭环。Cursor 的 Context 体系里，最核心的四块是：</p><ul><li><strong>Rules</strong>：把团队/项目约束沉淀为长期可管理的指令层</li><li><strong>Subagents</strong>：把复杂任务拆成可委派、可并行、可恢复的子任务</li><li><strong>Skills</strong>：把领域知识 + 工作流 + 脚本资源打包成可移植能力</li><li><strong>MCP</strong>：把 Agent 连接到外部工具与数据源（工单/知识库/DB/云服务等）</li></ul><p>本文从“工程化视角”逐一对照这四者的定位、配置入口、适用场景、常见坑与组合策略。</p><h2 id="_1-一张表先对齐-四件套各解决什么问题" tabindex="-1">1. 一张表先对齐：四件套各解决什么问题 <a class="header-anchor" href="#_1-一张表先对齐-四件套各解决什么问题" aria-label="Permalink to &quot;1. 一张表先对齐：四件套各解决什么问题&quot;">​</a></h2><table tabindex="0"><thead><tr><th>能力</th><th>解决的问题</th><th>典型产物</th><th>适合场景</th><th>主要代价</th></tr></thead><tbody><tr><td>Rules</td><td>让指令“可持续生效、可管理、可共享”</td><td>Project/Team/User Rules，AGENTS.md</td><td>代码风格、目录规范、协作约束、输出格式</td><td>规则写不好会变噪音；Always Apply 过多会增加上下文负担</td></tr><tr><td>Subagents</td><td>让任务“可分工、可隔离、可并行、可恢复”</td><td><code>.cursor/agents/*.md</code></td><td>调试/验证/测试/安全审计/并行评估</td><td>token 成本上升，简单任务可能更慢</td></tr><tr><td>Skills</td><td>让能力“可移植、可版本化、可执行（脚本）”</td><td><code>.cursor/skills/&lt;skill&gt;/SKILL.md</code> + scripts/references/assets</td><td>部署、验收、文档生成、代码检查自动化</td><td>维护成本，且当前仅 nightly 渠道</td></tr><tr><td>MCP</td><td>让 Agent “能用外部工具/访问外部系统”</td><td>MCP server 配置（本地或远程）</td><td>工单/知识库同步、DB 查询、云资源管理、扫描工具</td><td>凭据/权限治理、安全审计与可观测性</td></tr></tbody></table><p>接下来逐个拆开。</p><h2 id="_2-rules-把-协作约束-从提示词搬到规则层" tabindex="-1">2. Rules：把“协作约束”从提示词搬到规则层 <a class="header-anchor" href="#_2-rules-把-协作约束-从提示词搬到规则层" aria-label="Permalink to &quot;2. Rules：把“协作约束”从提示词搬到规则层&quot;">​</a></h2><h3 id="_2-1-三层规则与优先级" tabindex="-1">2.1 三层规则与优先级 <a class="header-anchor" href="#_2-1-三层规则与优先级" aria-label="Permalink to &quot;2.1 三层规则与优先级&quot;">​</a></h3><p>Rules 的价值在于<strong>稳定性与一致性</strong>：不用每次对话都重复“请按某某风格、某某目录结构、某某输出格式”。</p><p>你需要记住一个优先级：</p><ul><li><strong>Team Rules → Project Rules → User Rules</strong></li></ul><p>当存在冲突时，靠前的来源优先。</p><h3 id="_2-2-project-rules-文件化、可版本控制" tabindex="-1">2.2 Project Rules：文件化、可版本控制 <a class="header-anchor" href="#_2-2-project-rules-文件化、可版本控制" aria-label="Permalink to &quot;2.2 Project Rules：文件化、可版本控制&quot;">​</a></h3><p>Project Rules 通常放在项目中（并提交到仓库），适合固化：</p><ul><li>目录结构与边界（例如：业务逻辑不得写进 UI 层）</li><li>编码规范（命名、异常处理、日志、测试）</li><li>输出格式（变更说明模板、PR 描述结构）</li></ul><p>Project Rules 的关键是 frontmatter（官方文档中最重要的是“它如何生效”）：</p><ul><li><code>description</code>：用于 <strong>Apply Intelligently</strong> 类型规则。Agent 会读取描述来决定是否把该规则注入当前上下文。</li><li><code>alwaysApply</code>：用于 <strong>Always Apply</strong> 类型规则。 <ul><li><code>true</code>：每次对话都会注入</li><li><code>false</code>：由 Agent 决定是否应用（通常更推荐）</li></ul></li></ul><p>另外，Project Rules 还可以做成“只对特定文件生效”的规则（官方称 <strong>Apply to Specific Files</strong>），通常通过 <code>globs</code>（文件匹配模式）来限定生效范围。</p><p><strong>工程化建议</strong>：</p><ul><li>默认使用 Apply Intelligently（也就是 <code>alwaysApply: false</code>），只把真正的“硬约束”设为 Always Apply</li><li>规则正文尽量短，把长内容拆到独立文件，并在规则里用 <code>@filename</code> 的方式按需引入（官方支持用 <code>@filename.ts</code> 这类语法把文件内容包含进上下文）</li></ul><h3 id="_2-3-agents-md-更轻量的-项目指令入口" tabindex="-1">2.3 AGENTS.md：更轻量的“项目指令入口” <a class="header-anchor" href="#_2-3-agents-md-更轻量的-项目指令入口" aria-label="Permalink to &quot;2.3 AGENTS.md：更轻量的“项目指令入口”&quot;">​</a></h3><p>如果你的需求只是“在根目录放一份清晰的人类可读规则”，AGENTS.md 更轻：</p><ul><li>纯 Markdown，无复杂元数据</li><li>支持嵌套：子目录的 AGENTS.md 会与父目录合并，更具体的优先</li></ul><p>适合：</p><ul><li>多栈项目（frontend/backend/components 各自有局部指令）</li><li>不想引入结构化规则成本的团队</li></ul><h3 id="_2-4-边界与误区" tabindex="-1">2.4 边界与误区 <a class="header-anchor" href="#_2-4-边界与误区" aria-label="Permalink to &quot;2.4 边界与误区&quot;">​</a></h3><ul><li><strong>Rules 不会影响 Cursor Tab</strong>（规则主要用于 Agent/Chat）</li><li><strong>User Rules 不会应用到 Inline Edit（Cmd/Ctrl+K）</strong>（官方明确：用户规则只用于 Agent/Chat）</li><li>Team Rules 是由团队/企业在 Dashboard 侧创建与管理的组织级规则，它与 Project Rules 不同：Team Rules 更像“组织层的统一指令”，不走 Project Rules 的文件结构与元数据（例如不支持 <code>globs</code>、<code>alwaysApply</code> 等 Project Rules 的 frontmatter）</li><li>旧的 <code>.cursorrules</code> 仍可用但趋于废弃，建议迁移到 Project Rules 或 AGENTS.md</li></ul><h3 id="_2-5-context-commands-把高频操作固化为-命令" tabindex="-1">2.5 Context Commands：把高频操作固化为“/命令” <a class="header-anchor" href="#_2-5-context-commands-把高频操作固化为-命令" aria-label="Permalink to &quot;2.5 Context Commands：把高频操作固化为“/命令”&quot;">​</a></h3><p>除了 Rules（长期指令）之外，Cursor 还支持 <strong>Context Commands</strong>：在 Agent 聊天输入框中输入 <code>/</code> 会弹出可用命令列表，用于把高频操作固化成“一键触发”的工作流。</p><p>官方文档：<a href="https://cursor.com/cn/docs/context/commands" target="_blank" rel="noreferrer">https://cursor.com/cn/docs/context/commands</a></p><p>命令以普通 Markdown 文件的形式定义，可以存放在三个位置：</p><ul><li><strong>项目命令</strong>：放在项目的 <code>.cursor/commands</code> 目录</li><li><strong>全局命令</strong>：放在主目录下的 <code>~/.cursor/commands</code> 目录</li><li><strong>团队命令</strong>：由团队管理员在 Cursor Dashboard 创建并集中管理（Team / Enterprise 方案），创建后会自动对团队成员可用</li></ul><p>创建项目命令的最小步骤（官方说明）：</p><ul><li>在项目根目录创建 <code>.cursor/commands/</code></li><li>在该目录中添加若干 <code>.md</code> 文件（文件名就是命令名，例如 <code>review-code.md</code>）</li><li>用纯 Markdown 写清楚“这个命令应该执行什么”</li></ul><p>参数传递方式：在命令名称之后输入的任何内容，都会与命令内容一起包含进提示词中（例如：<code>/commit and /pr these changes to address DX-523</code>）。</p><h2 id="_3-subagents-把-复杂任务-拆成可委派的可执行单元" tabindex="-1">3. Subagents：把“复杂任务”拆成可委派的可执行单元 <a class="header-anchor" href="#_3-subagents-把-复杂任务-拆成可委派的可执行单元" aria-label="Permalink to &quot;3. Subagents：把“复杂任务”拆成可委派的可执行单元&quot;">​</a></h2><p>Subagents 的关键价值是：</p><ul><li><strong>上下文隔离</strong>：每个子代理可以在自己的上下文里收集信息、执行任务，避免把主对话搅得很“脏”</li><li><strong>并行</strong>：复杂任务可以拆开并行跑（但 token 成本会随并行数上升）</li></ul><h3 id="_3-1-存放位置与覆盖规则" tabindex="-1">3.1 存放位置与覆盖规则 <a class="header-anchor" href="#_3-1-存放位置与覆盖规则" aria-label="Permalink to &quot;3.1 存放位置与覆盖规则&quot;">​</a></h3><ul><li>项目级：<code>.cursor/agents/</code>（建议提交仓库）</li><li>用户级：<code>~/.cursor/agents/</code>（你个人所有项目可用）</li><li>同名冲突：项目级优先</li></ul><h3 id="_3-2-文件格式与关键字段" tabindex="-1">3.2 文件格式与关键字段 <a class="header-anchor" href="#_3-2-文件格式与关键字段" aria-label="Permalink to &quot;3.2 文件格式与关键字段&quot;">​</a></h3><p>一个 subagent 是“带 YAML frontmatter 的 Markdown 文件”。常用字段：</p><ul><li><code>name</code>：唯一标识（小写+连字符更稳）</li><li><code>description</code>：决定何时被自动委派，<strong>这是最重要的字段</strong></li><li><code>model</code>：<code>fast</code> / <code>inherit</code> / 指定模型 ID</li><li><code>readonly: true</code>：让子代理在受限写入权限下运行（适合审计/评审类）</li><li><code>is_background: true</code>：后台执行，不阻塞主对话</li></ul><h3 id="_3-3-触发方式-自动委派-vs-显式调用" tabindex="-1">3.3 触发方式：自动委派 vs 显式调用 <a class="header-anchor" href="#_3-3-触发方式-自动委派-vs-显式调用" aria-label="Permalink to &quot;3.3 触发方式：自动委派 vs 显式调用&quot;">​</a></h3><ul><li><strong>自动委派</strong>：靠 <code>description</code>，建议写清楚触发条件，并可以使用 “use proactively / always use for” 之类短语引导</li><li><strong>显式调用</strong>：在对话里用 <code>/name</code> 调用（例如 <code>/verifier</code>）</li></ul><h3 id="_3-4-并行与恢复" tabindex="-1">3.4 并行与恢复 <a class="header-anchor" href="#_3-4-并行与恢复" aria-label="Permalink to &quot;3.4 并行与恢复&quot;">​</a></h3><ul><li>Subagents 可以并行跑：例如“一个跑测试、一个做安全审计、一个更新文档”</li><li>长任务可以恢复：拿到 agent id 后继续执行（适合跨多轮对话的工作）</li><li>后台子代理的输出会写入本机目录（官方示例为 <code>~/.cursor/subagents/</code>），父代理可以读取这些文件检查进度</li></ul><h3 id="_3-5-成本模型-务实" tabindex="-1">3.5 成本模型（务实） <a class="header-anchor" href="#_3-5-成本模型-务实" aria-label="Permalink to &quot;3.5 成本模型（务实）&quot;">​</a></h3><ul><li>Subagent 会独立消耗 token；并行数越多，总消耗通常越接近线性增长（并行 5 个时，量级上接近 5 倍，但具体取决于每个子代理的上下文与任务长度）</li><li>简单任务（改一行配置）通常主 agent 更快</li><li>复杂任务（多文件变更、需要验证/并行）subagent 更稳、更可控</li></ul><h2 id="_4-skills-把-领域能力-做成可移植包" tabindex="-1">4. Skills：把“领域能力”做成可移植包 <a class="header-anchor" href="#_4-skills-把-领域能力-做成可移植包" aria-label="Permalink to &quot;4. Skills：把“领域能力”做成可移植包&quot;">​</a></h2><p>Skills 的定位是：把某类任务的“最佳实践 + 脚本 + 参考资料”封装成一个包，让 Agent 在合适的时候调用。</p><h3 id="_4-1-可用性与目录" tabindex="-1">4.1 可用性与目录 <a class="header-anchor" href="#_4-1-可用性与目录" aria-label="Permalink to &quot;4.1 可用性与目录&quot;">​</a></h3><ul><li>Agent Skills 当前在 <strong>nightly 渠道</strong>（写作/团队推广时要明确这点）</li><li>Skills 会从这些目录自动发现： <ul><li><code>.cursor/skills/</code>（项目级）</li><li><code>.claude/skills/</code>（项目级，兼容 Claude）</li><li><code>~/.cursor/skills/</code>（用户级）</li><li><code>~/.claude/skills/</code>（用户级）</li></ul></li></ul><h3 id="_4-2-skill-的结构约束" tabindex="-1">4.2 Skill 的结构约束 <a class="header-anchor" href="#_4-2-skill-的结构约束" aria-label="Permalink to &quot;4.2 Skill 的结构约束&quot;">​</a></h3><p>每个 skill 是一个文件夹，必须包含：</p><ul><li><code>SKILL.md</code></li></ul><p><code>SKILL.md</code> 的 frontmatter 至少需要：</p><ul><li><code>name</code>（必须与父文件夹名一致；只允许小写/数字/连字符）</li><li><code>description</code>（写清楚“何时用”）</li></ul><h3 id="_4-3-可选目录-scripts-references-assets" tabindex="-1">4.3 可选目录：scripts / references / assets <a class="header-anchor" href="#_4-3-可选目录-scripts-references-assets" aria-label="Permalink to &quot;4.3 可选目录：scripts / references / assets&quot;">​</a></h3><ul><li><code>scripts/</code>：可执行脚本（bash/python/node 等）</li><li><code>references/</code>：按需加载的补充文档（规范/流程/模板）</li><li><code>assets/</code>：配置模板、图片、数据文件</li></ul><p><strong>工程化建议</strong>：</p><ul><li>主 <code>SKILL.md</code> 保持短，把长内容放 <code>references/</code>，让 Agent 按需加载</li><li>脚本要自包含、错误信息清晰、能优雅失败（便于 Agent 做重试与诊断）</li></ul><h3 id="_4-4-skills-与-rules-的关系" tabindex="-1">4.4 Skills 与 Rules 的关系 <a class="header-anchor" href="#_4-4-skills-与-rules-的关系" aria-label="Permalink to &quot;4.4 Skills 与 Rules 的关系&quot;">​</a></h3><p>在 Cursor 里，Skills 会出现在 Rules 相关设置里，并且作为“由 Agent 决定是否应用（Agent Decides）”的形态出现。官方也强调：Skills 不能配置为“始终应用（always apply）”或“手动（manual）”规则。</p><p>另外，官方提供了从 GitHub 导入（Remote Rule / GitHub）的方式把外部规则/技能同步到项目里：适合团队共享与版本迭代。</p><h2 id="_5-mcp-把-agent-连接到外部系统-工具与数据" tabindex="-1">5. MCP：把 Agent 连接到外部系统（工具与数据） <a class="header-anchor" href="#_5-mcp-把-agent-连接到外部系统-工具与数据" aria-label="Permalink to &quot;5. MCP：把 Agent 连接到外部系统（工具与数据）&quot;">​</a></h2><p>如果说 Rules/Subagents/Skills 主要解决“对话内与代码库内”的问题，那么 MCP 解决的是：让 Cursor 能通过标准协议连接外部工具与数据源，把 Agent 的能力从“写代码”扩展到“与系统交互”。</p><ul><li>工单系统（Jira/Linear/ClickUp）</li><li>知识库（Confluence/Notion 类）</li><li>代码托管与流水线（GitHub/GitLab/CI/CD）</li><li>安全/扫描（Semgrep/Snyk/SonarQube）</li></ul><h3 id="_5-1-常见部署形态与传输方式" tabindex="-1">5.1 常见部署形态与传输方式 <a class="header-anchor" href="#_5-1-常见部署形态与传输方式" aria-label="Permalink to &quot;5.1 常见部署形态与传输方式&quot;">​</a></h3><p>文档里能看到多种 transport：</p><ul><li><code>stdio</code>：本地启动一个进程作为 MCP server</li><li><code>sse</code> / <code>http</code> / <code>https</code> / <code>streamable-http</code>：远程 MCP server</li></ul><p>工程化选型建议：</p><ul><li>个人使用：优先 <code>stdio</code> 或可信的托管服务</li><li>团队使用：优先可审计、可统一管理的远程服务 + OAuth</li></ul><h3 id="_5-2-鉴权与安全底线" tabindex="-1">5.2 鉴权与安全底线 <a class="header-anchor" href="#_5-2-鉴权与安全底线" aria-label="Permalink to &quot;5.2 鉴权与安全底线&quot;">​</a></h3><p>MCP 的最大风险点是“让 Agent 能够对外部系统做真实动作”。建议默认遵循：</p><ul><li>不要在仓库里硬编码任何 token</li><li>优先 OAuth，其次环境变量注入的 API Key</li><li>能只读就只读（尤其是知识库/工单系统）</li></ul><h3 id="_5-3-什么时候该用-mcp、什么时候不该用" tabindex="-1">5.3 什么时候该用 MCP、什么时候不该用 <a class="header-anchor" href="#_5-3-什么时候该用-mcp、什么时候不该用" aria-label="Permalink to &quot;5.3 什么时候该用 MCP、什么时候不该用&quot;">​</a></h3><ul><li>需要读取/写入外部系统状态（创建工单、更新页面、查部署状态）→ MCP</li><li>只是要“按模板生成文本”→ Rules/Skills 更合适</li><li>需要强隔离审计逻辑 → 用 subagent（必要时 readonly），而不是把所有能力都塞给主 agent</li></ul><h2 id="_6-组合策略-四件套如何协同" tabindex="-1">6. 组合策略：四件套如何协同 <a class="header-anchor" href="#_6-组合策略-四件套如何协同" aria-label="Permalink to &quot;6. 组合策略：四件套如何协同&quot;">​</a></h2><p>一个可复用的组合套路：</p><ul><li><strong>Rules</strong>：约束输入（风格、目录、测试策略、输出格式）</li><li><strong>Subagents</strong>：拆分执行与验证（实现/测试/审计/验收）</li><li><strong>Skills</strong>：沉淀可执行工作流（脚本化、模板化、按需加载资料）</li><li><strong>MCP</strong>：与外部系统同步（工单/知识库/扫描平台）</li></ul><p>例如“修复一个线上 Bug 并更新 Confluence 复盘页”的流程：</p><ul><li>主 agent 做实现</li><li><code>test-runner</code> subagent 跑测试与修复失败</li><li><code>verifier</code> subagent 验收</li><li><code>docs-writer</code> skill 生成复盘模板</li><li>MCP 更新 Confluence 页面、把 Jira 工单状态从 In Progress → Done</li></ul><h2 id="_7-反模式清单-建议贴到团队规范里" tabindex="-1">7. 反模式清单（建议贴到团队规范里） <a class="header-anchor" href="#_7-反模式清单-建议贴到团队规范里" aria-label="Permalink to &quot;7. 反模式清单（建议贴到团队规范里）&quot;">​</a></h2><ul><li>Rules：把所有东西都设成 alwaysApply（上下文污染 + token 浪费）</li><li>Subagents：创建几十个“泛用 helper”，description 模糊导致永远不会触发</li><li>Skills：把长文档都塞进 SKILL.md，导致每次调用都很重</li><li>MCP：默认给写权限、默认用高权限 token（安全风险极高）</li></ul><h2 id="_8-下一步-把-工程化对照-落地为一套模板" tabindex="-1">8. 下一步：把“工程化对照”落地为一套模板 <a class="header-anchor" href="#_8-下一步-把-工程化对照-落地为一套模板" aria-label="Permalink to &quot;8. 下一步：把“工程化对照”落地为一套模板&quot;">​</a></h2><p>如果你希望“直接抄一套配置”，下一篇文章会给一套端到端工作流模板：</p><ul><li>Rules 管约束</li><li>Subagents 管分工与验收</li><li>Skills 管脚本化与文档化</li><li>MCP 接入工单/知识库（你选的 B 类）</li></ul>',88))])}const M=d(_,[["render",C]]);export{y as __pageData,M as default};
